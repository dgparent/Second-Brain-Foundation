"""
Entity Management API with Truth Hierarchy Support
Provides endpoints for entity CRUD and truth-level operations
"""

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import Dict, List, Optional, Any
from datetime import datetime

from ..services.vault_storage import LocalVaultStorage, VaultEntity
from ..models.truth_hierarchy import TruthLevel, OriginSource

router = APIRouter(prefix="/entities", tags=["entities"])


# Request/Response Models
class CreateEntityRequest(BaseModel):
    title: str
    content: str
    vault_path: str
    truth_level: TruthLevel = TruthLevel.USER
    origin_source: OriginSource = 'user:web'
    metadata: Optional[Dict[str, Any]] = None


class UpdateEntityRequest(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    truth_level: TruthLevel = TruthLevel.USER
    origin_source: OriginSource = 'user:web'


class AcceptSuggestionRequest(BaseModel):
    user_id: str


class EntityResponse(BaseModel):
    id: str
    vault_path: str
    title: str
    content: str
    truth_metadata: Dict[str, Any]
    metadata: Dict[str, Any]


# Dependency to get vault storage
# TODO: Make this tenant-aware
def get_vault_storage() -> LocalVaultStorage:
    # TODO: Get from config/env
    vault_root = "C:\\Users\\YourUser\\Documents\\2BF-Vault"  # Placeholder
    return LocalVaultStorage(vault_root, enable_watch=False)


@router.post("/", response_model=EntityResponse)
async def create_entity(
    request: CreateEntityRequest,
    storage: LocalVaultStorage = Depends(get_vault_storage)
):
    """Create a new entity in the vault"""
    try:
        entity = storage.create_entity(
            title=request.title,
            content=request.content,
            vault_path=request.vault_path,
            truth_level=request.truth_level,
            origin_source=request.origin_source,
            metadata=request.metadata
        )
        
        return EntityResponse(**entity.to_dict())
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{vault_path:path}", response_model=EntityResponse)
async def get_entity(
    vault_path: str,
    storage: LocalVaultStorage = Depends(get_vault_storage)
):
    """Get entity by vault path"""
    entity = storage.get_entity(vault_path)
    
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")
    
    return EntityResponse(**entity.to_dict())


@router.put("/{vault_path:path}", response_model=EntityResponse)
async def update_entity(
    vault_path: str,
    request: UpdateEntityRequest,
    storage: LocalVaultStorage = Depends(get_vault_storage)
):
    """Update an entity"""
    updates = {}
    
    if request.title is not None:
        updates['title'] = request.title
    if request.content is not None:
        updates['content'] = request.content
    if request.metadata is not None:
        updates['metadata'] = request.metadata
    
    entity = storage.update_entity(
        vault_path=vault_path,
        updates=updates,
        truth_level=request.truth_level,
        origin_source=request.origin_source
    )
    
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")
    
    return EntityResponse(**entity.to_dict())


@router.delete("/{vault_path:path}")
async def delete_entity(
    vault_path: str,
    storage: LocalVaultStorage = Depends(get_vault_storage)
):
    """Delete an entity"""
    success = storage.delete_entity(vault_path)
    
    if not success:
        raise HTTPException(status_code=404, detail="Entity not found")
    
    return {"status": "deleted", "vault_path": vault_path}


@router.get("/")
async def list_entities(
    storage: LocalVaultStorage = Depends(get_vault_storage)
):
    """List all entities in vault"""
    entities = storage.scan_all()
    
    return {
        "entities": [EntityResponse(**e.to_dict()) for e in entities],
        "count": len(entities)
    }


@router.post("/{vault_path:path}/accept", response_model=EntityResponse)
async def accept_suggestion(
    vault_path: str,
    request: AcceptSuggestionRequest,
    storage: LocalVaultStorage = Depends(get_vault_storage)
):
    """
    Accept an AI/automation suggestion and upgrade to User truth level (U1)
    
    This is the critical endpoint for user sovereignty - it allows users to
    explicitly accept content generated by AI or automations, upgrading it
    from lower truth levels (A2-C5) to U1.
    
    The acceptance is recorded in the origin chain for full provenance.
    """
    entity = storage.accept_suggestion(vault_path, request.user_id)
    
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")
    
    return EntityResponse(**entity.to_dict())


@router.get("/{vault_path:path}/history")
async def get_entity_history(
    vault_path: str,
    storage: LocalVaultStorage = Depends(get_vault_storage)
):
    """Get modification history (origin chain) for an entity"""
    entity = storage.get_entity(vault_path)
    
    if not entity:
        raise HTTPException(status_code=404, detail="Entity not found")
    
    return {
        "entity_id": entity.id,
        "vault_path": entity.vault_path,
        "current_truth_level": entity.truth_metadata.truth_level,
        "origin_chain": [
            {
                'timestamp': entry.timestamp.isoformat(),
                'truth_level': entry.truth_level,
                'source': entry.source,
                'action': entry.action,
                'metadata': entry.metadata
            }
            for entry in entity.truth_metadata.origin_chain
        ]
    }
